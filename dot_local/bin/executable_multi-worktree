#!/usr/bin/env bash

# multi-worktree: マルチリポジトリ × git worktree 管理ツール
# 複数のリポジトリに対して、タスク単位で worktree を一括作成・管理する

set -euo pipefail

# カラー定義
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly NC='\033[0m' # No Color

# 設定ファイルのパス
readonly CONFIG_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/multi-worktree"
readonly CONFIG_FILE="${CONFIG_DIR}/config.toml"

# ログ関数
log_info() {
    echo -e "${BLUE}[INFO]${NC} $*"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $*"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $*"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $*" >&2
}

# 使用方法を表示
show_usage() {
    cat <<EOF
Usage: multi-worktree <subcommand> [options]

マルチリポジトリ × git worktree 管理ツール

サブコマンド:
  create <task-name> [--group=GROUP]  マルチrepoのworktreeを一括作成
  remove <task-name>                   worktreeを一括削除
  list                                 タスク一覧表示（group列を含む）
  status <task-name>                   各repoの状態確認
  sync <task-name> [repo...]          worktreeの内容をメインworktreeに同期
  cd <task-name>                       worktreeディレクトリに移動
  exec <task-name> <command>           devcontainerでコマンド実行
  open <task-name>                     VSCodeでworktreeを開く
  help                                 このヘルプを表示

オプション:
  --group=GROUP  使用するリポジトリグループ（createコマンドのみ、デフォルト: default）

例:
  multi-worktree create feat/add-auth
  multi-worktree create feat/new-feature --group=work
  multi-worktree list
  multi-worktree status feat/add-auth
  multi-worktree sync feat/add-auth                    # 全リポジトリを同期
  multi-worktree sync feat/add-auth repo1 repo2        # 特定のリポジトリのみ同期
  multi-worktree cd feat/add-auth
  multi-worktree exec feat/add-auth ccmanager
  multi-worktree open feat/add-auth
  multi-worktree remove feat/add-auth
EOF
}

# 設定ファイルの存在チェック
check_config() {
    if [[ ! -f "$CONFIG_FILE" ]]; then
        log_error "設定ファイルが見つかりません: $CONFIG_FILE"
        log_info "サンプル設定ファイルを作成してください:"
        log_info "  mkdir -p $CONFIG_DIR"
        log_info "  cat > $CONFIG_FILE <<'TOML'"
        log_info "[groups.default]"
        log_info "repos = [\"/path/to/repo1\", \"/path/to/repo2\"]"
        log_info "base_dir = \"../worktrees\""
        log_info "worktree_prefix = \"multi-worktree\""
        log_info ""
        log_info "[settings]"
        log_info "default_group = \"default\""
        log_info "TOML"
        return 1
    fi
}

# TOML 設定ファイルから値を読み込む（簡易実装）
# 引数: グループ名, キー名
get_config_value() {
    local group="$1"
    local key="$2"
    local in_group=false
    local value=""

    while IFS= read -r line; do
        # コメントと空行をスキップ
        [[ "$line" =~ ^[[:space:]]*# ]] && continue
        [[ -z "${line// /}" ]] && continue

        # グループセクションの検出
        if [[ "$line" =~ ^\[groups\.$group\] ]]; then
            in_group=true
            continue
        elif [[ "$line" =~ ^\[.*\] ]]; then
            in_group=false
            continue
        fi

        # グループ内でキーを探す
        if [[ "$in_group" == true ]] && [[ "$line" =~ ^[[:space:]]*$key[[:space:]]*= ]]; then
            value=$(echo "$line" | sed -E 's/^[[:space:]]*'"$key"'[[:space:]]*=[[:space:]]*//' | sed -E 's/^"(.*)"$/\1/' | sed -E "s/^'(.*)'$/\1/")
            echo "$value"
            return 0
        fi
    done < "$CONFIG_FILE"

    return 1
}

# 配列形式の設定値を読み込む
# 引数: グループ名, キー名
get_config_array() {
    local group="$1"
    local key="$2"
    local in_group=false
    local in_array=false
    local result=()

    while IFS= read -r line; do
        # コメントと空行をスキップ
        [[ "$line" =~ ^[[:space:]]*# ]] && continue

        # グループセクションの検出
        if [[ "$line" =~ ^\[groups\.$group\] ]]; then
            in_group=true
            continue
        elif [[ "$line" =~ ^\[.*\] ]]; then
            in_group=false
            in_array=false
            continue
        fi

        # 配列の開始を検出
        if [[ "$in_group" == true ]] && [[ "$line" =~ ^[[:space:]]*$key[[:space:]]*=[[:space:]]*\[ ]]; then
            in_array=true
            # 同じ行に要素がある場合
            local content=$(echo "$line" | sed -E 's/^[[:space:]]*'"$key"'[[:space:]]*=[[:space:]]*\[//' | sed 's/\]//')
            if [[ -n "$content" ]]; then
                IFS=',' read -ra items <<< "$content"
                for item in "${items[@]}"; do
                    item=$(echo "$item" | sed -E 's/^[[:space:]]*"(.*)"[[:space:]]*$/\1/' | sed -E "s/^[[:space:]]*'(.*)'[[:space:]]*$/\1/" | xargs)
                    [[ -n "$item" ]] && result+=("$item")
                done
            fi
            [[ "$line" =~ \] ]] && in_array=false
            continue
        fi

        # 配列要素の読み込み
        if [[ "$in_array" == true ]]; then
            if [[ "$line" =~ \] ]]; then
                in_array=false
                local content=$(echo "$line" | sed 's/\]//')
                if [[ -n "$content" ]]; then
                    IFS=',' read -ra items <<< "$content"
                    for item in "${items[@]}"; do
                        item=$(echo "$item" | sed -E 's/^[[:space:]]*"(.*)"[[:space:]]*$/\1/' | sed -E "s/^[[:space:]]*'(.*)'[[:space:]]*$/\1/" | xargs)
                        [[ -n "$item" ]] && result+=("$item")
                    done
                fi
            else
                IFS=',' read -ra items <<< "$line"
                for item in "${items[@]}"; do
                    item=$(echo "$item" | sed -E 's/^[[:space:]]*"(.*)"[[:space:]]*$/\1/' | sed -E "s/^[[:space:]]*'(.*)'[[:space:]]*$/\1/" | xargs)
                    [[ -n "$item" ]] && result+=("$item")
                done
            fi
        fi
    done < "$CONFIG_FILE"

    printf '%s\n' "${result[@]}"
}

# パス展開（~ と $HOME）
expand_path() {
    local path="$1"
    path="${path/#\~/$HOME}"
    path="${path//\$HOME/$HOME}"
    echo "$path"
}

# デフォルトグループの取得
get_default_group() {
    local value=""
    local in_settings=false

    while IFS= read -r line; do
        # コメントと空行をスキップ
        [[ "$line" =~ ^[[:space:]]*# ]] && continue
        [[ -z "${line// /}" ]] && continue

        # [settings] セクションの検出
        if [[ "$line" =~ ^\[settings\] ]]; then
            in_settings=true
            continue
        elif [[ "$line" =~ ^\[.*\] ]]; then
            in_settings=false
            continue
        fi

        # settings 内で default_group を探す
        if [[ "$in_settings" == true ]] && [[ "$line" =~ ^[[:space:]]*default_group[[:space:]]*= ]]; then
            value=$(echo "$line" | sed -E 's/^[[:space:]]*default_group[[:space:]]*=[[:space:]]*//' | sed -E 's/^"(.*)"$/\1/' | sed -E "s/^'(.*)'$/\1/")
            echo "$value"
            return 0
        fi
    done < "$CONFIG_FILE"

    echo "default"
}

# base_dirを絶対パスに解決する共通関数
resolve_base_dir() {
    local base_dir="$1"
    local group="$2"

    # すでに絶対パスの場合はそのまま返す
    if [[ "$base_dir" == /* ]]; then
        echo "$base_dir"
        return 0
    fi

    # 相対パスの場合、最初のリポジトリを基準に絶対パスを取得
    local repos=()
    while IFS= read -r repo; do
        repos+=("$repo")
    done < <(get_config_array "$group" "repos")

    if [[ ${#repos[@]} -gt 0 ]]; then
        local first_repo="${repos[0]}"
        first_repo="${first_repo/#\~/$HOME}"
        first_repo="${first_repo//\$HOME/$HOME}"

        if [[ -d "$first_repo" ]]; then
            # 最初のリポジトリのディレクトリからの相対パスとして解決
            local resolved_path=$(cd "$first_repo" && cd "$base_dir" 2>/dev/null && pwd)
            if [[ -n "$resolved_path" ]]; then
                echo "$resolved_path"
                return 0
            fi
        fi
    fi

    # 解決できない場合は元のパスをそのまま返す
    echo "$base_dir"
}

# worktree のベースディレクトリを取得
get_worktree_base_dir() {
    local task_name="$1"
    local group="${2:-$(get_default_group)}"

    local base_dir=$(expand_path "$(get_config_value "$group" "base_dir")")
    local prefix=$(get_config_value "$group" "worktree_prefix")

    # base_dirを絶対パスに解決
    base_dir=$(resolve_base_dir "$base_dir" "$group")

    # タスク名から / を - に変換してディレクトリ名を作成
    local dir_name=$(echo "$task_name" | sed 's/\//-/g')

    echo "${base_dir}/${prefix}-${dir_name}"
}

# devcontainer up オプションの取得
get_devcontainer_up_opts() {
    local group="$1"
    local in_group=false
    local in_devcontainer=false
    local opts=""

    while IFS= read -r line; do
        [[ "$line" =~ ^[[:space:]]*# ]] && continue
        [[ -z "${line// /}" ]] && continue

        if [[ "$line" =~ ^\[groups\.$group\] ]]; then
            in_group=true
            continue
        elif [[ "$line" =~ ^\[groups\.$group\.devcontainer\] ]]; then
            in_devcontainer=true
            continue
        elif [[ "$line" =~ ^\[.*\] ]]; then
            in_group=false
            in_devcontainer=false
            continue
        fi

        if [[ "$in_devcontainer" == true ]] && [[ "$line" =~ ^[[:space:]]*up_opts[[:space:]]*= ]]; then
            opts=$(echo "$line" | sed -E 's/^[[:space:]]*up_opts[[:space:]]*=[[:space:]]*//' | \
                   sed 's/\[//g' | sed 's/\]//g' | sed 's/"//g' | sed "s/'//g" | sed 's/,/ /g')
            break
        fi
    done < "$CONFIG_FILE"

    if [[ -z "$opts" ]]; then
        opts="--workspace-folder ."
    fi

    echo "$opts"
}

# devcontainer exec オプションの取得
get_devcontainer_exec_opts() {
    local group="$1"
    local in_devcontainer=false
    local opts=""

    while IFS= read -r line; do
        [[ "$line" =~ ^[[:space:]]*# ]] && continue
        [[ -z "${line// /}" ]] && continue

        if [[ "$line" =~ ^\[groups\.$group\.devcontainer\] ]]; then
            in_devcontainer=true
            continue
        elif [[ "$line" =~ ^\[.*\] ]]; then
            in_devcontainer=false
            continue
        fi

        if [[ "$in_devcontainer" == true ]] && [[ "$line" =~ ^[[:space:]]*exec_opts[[:space:]]*= ]]; then
            opts=$(echo "$line" | sed -E 's/^[[:space:]]*exec_opts[[:space:]]*=[[:space:]]*//' | \
                   sed 's/\[//g' | sed 's/\]//g' | sed 's/"//g' | sed "s/'//g" | sed 's/,/ /g')
            break
        fi
    done < "$CONFIG_FILE"

    if [[ -z "$opts" ]]; then
        opts="--workspace-folder ."
    fi

    echo "$opts"
}

# skip_up_if_running 設定の取得
get_devcontainer_skip_up_if_running() {
    local in_settings=false
    local value=""

    while IFS= read -r line; do
        [[ "$line" =~ ^[[:space:]]*# ]] && continue
        [[ -z "${line// /}" ]] && continue

        if [[ "$line" =~ ^\[settings\.devcontainer\] ]]; then
            in_settings=true
            continue
        elif [[ "$line" =~ ^\[.*\] ]]; then
            in_settings=false
            continue
        fi

        if [[ "$in_settings" == true ]] && [[ "$line" =~ ^[[:space:]]*skip_up_if_running[[:space:]]*= ]]; then
            value=$(echo "$line" | sed -E 's/^[[:space:]]*skip_up_if_running[[:space:]]*=[[:space:]]*//' | \
                    sed 's/"//g' | sed "s/'//g")
            break
        fi
    done < "$CONFIG_FILE"

    if [[ -z "$value" ]]; then
        echo "true"
    else
        echo "$value"
    fi
}

# create サブコマンド
cmd_create() {
    local task_name="$1"
    local group="${2:-$(get_default_group)}"

    log_info "タスク '$task_name' の worktree を作成します (グループ: $group)"

    # 設定の読み込み
    local base_dir=$(get_config_value "$group" "base_dir")
    local prefix=$(get_config_value "$group" "worktree_prefix")

    if [[ -z "$base_dir" ]] || [[ -z "$prefix" ]]; then
        log_error "グループ '$group' の設定が見つかりません"
        return 1
    fi

    # リポジトリリストの取得
    local repos=()
    while IFS= read -r repo; do
        repos+=("$repo")
    done < <(get_config_array "$group" "repos")

    if [[ ${#repos[@]} -eq 0 ]]; then
        log_error "グループ '$group' にリポジトリが設定されていません"
        return 1
    fi

    log_info "対象リポジトリ: ${#repos[@]} 個"

    # worktree ベースディレクトリ
    local worktree_base_dir=$(get_worktree_base_dir "$task_name" "$group")

    log_info "作成先: $worktree_base_dir"

    # ベースディレクトリの作成
    mkdir -p "$worktree_base_dir"

    # 各リポジトリで worktree を作成
    local success_count=0
    local fail_count=0

    for repo in "${repos[@]}"; do
        # チルダ展開と環境変数展開
        repo="${repo/#\~/$HOME}"
        repo="${repo//\$HOME/$HOME}"

        if [[ ! -d "$repo" ]]; then
            log_warn "リポジトリが見つかりません: $repo"
            ((++fail_count))
            continue
        fi

        local repo_name=$(basename "$repo")
        local worktree_path="${worktree_base_dir}/${repo_name}"

        log_info "[$repo_name] worktree を作成中..."

        # リポジトリディレクトリに移動（サブシェルでエラーが発生しても継続）
        (
            set +e  # エラーで停止しない
            cd "$repo" || exit 1

            # デフォルトブランチを fetch
            if ! git fetch origin 2>/dev/null; then
                log_warn "[$repo_name] fetch に失敗しました"
            fi

            # worktree を作成
            # ブランチが既に存在する場合は -b オプションを使用しない
            local add_args=()
            if git show-ref --verify --quiet "refs/heads/$task_name"; then
                # ブランチが既に存在する場合
                add_args=("$task_name")
            else
                # ブランチが存在しない場合は新規作成
                add_args=("-b" "$task_name")
            fi

            local error_output
            if error_output=$(git worktree add "$worktree_path" "${add_args[@]}" 2>&1); then
                log_success "[$repo_name] worktree を作成しました: $worktree_path"
                exit 0
            else
                log_error "[$repo_name] worktree の作成に失敗しました"
                echo "  エラー: $error_output"
                exit 1
            fi
        )

        # サブシェルの終了ステータスを確認
        if [[ $? -eq 0 ]]; then
            ((++success_count))
        else
            ((++fail_count))
        fi
    done

    log_info "完了: 成功 $success_count / 失敗 $fail_count"

    # devcontainer.json の生成
    if [[ $success_count -gt 0 ]]; then
        log_info "devcontainer.json を生成中..."
        generate_devcontainer "$task_name" "$worktree_base_dir" "${repos[@]}"
    fi

    if [[ $fail_count -eq 0 ]]; then
        log_success "すべての worktree が正常に作成されました"
    else
        log_warn "一部の worktree の作成に失敗しました"
    fi
}

# devcontainer.json の生成
generate_devcontainer() {
    local task_name="$1"
    local worktree_base_dir="$2"
    shift 2
    local repos=("$@")

    # worktree_base_dir を絶対パスに変換
    if command -v realpath &>/dev/null; then
        worktree_base_dir=$(realpath "$worktree_base_dir")
    else
        # realpathが利用できない場合、cdで絶対パスを取得
        worktree_base_dir=$(cd "$worktree_base_dir" && pwd)
    fi

    local devcontainer_dir="${worktree_base_dir}/.devcontainer"
    mkdir -p "$devcontainer_dir"

    local devcontainer_file="${devcontainer_dir}/devcontainer.json"

    # タスク名から / を - に変換
    local task_dir_name=$(echo "$task_name" | sed 's/\//-/g')
    local worktree_name="multi-worktree-${task_dir_name}"

    # マウント設定を生成
    local mounts="["
    local first=true

    for repo in "${repos[@]}"; do
        # チルダ展開と環境変数展開
        repo="${repo/#\~/$HOME}"
        repo="${repo//\$HOME/$HOME}"
        [[ ! -d "$repo" ]] && continue

        local repo_name=$(basename "$repo")
        local worktree_path="${worktree_base_dir}/${repo_name}"

        [[ ! -d "$worktree_path" ]] && continue

        # 絶対パスに変換（realpathが利用可能な場合はそれを使用）
        if command -v realpath &>/dev/null; then
            worktree_path=$(realpath "$worktree_path")
        else
            # realpathが利用できない場合、cdで絶対パスを取得
            worktree_path=$(cd "$worktree_path" && pwd)
        fi

        if [[ "$first" == true ]]; then
            first=false
        else
            mounts+=","
        fi

        # worktree のマウント
        mounts+="\n    \"type=bind,source=${worktree_path},target=/workspaces/${worktree_name}/${repo_name}\""

        # 実体リポジトリのマウント（.git アクセス用）
        mounts+=",\n    \"type=bind,source=${repo},target=${repo}\""
    done

    # 共通設定のマウントを追加
    mounts+=",\n    \"type=bind,source=\${localEnv:HOME}/.config/git/config,target=/home/vscode/.gitconfig,readonly\""
    mounts+=",\n    \"type=bind,source=\${localEnv:HOME}/.config/gh,target=/home/vscode/.config/gh,readonly\""
    mounts+=",\n    \"type=bind,source=\${localEnv:HOME}/.claude,target=/home/vscode/.claude\""

    mounts+="\n  ]"

    # devcontainer.json を生成
    cat > "$devcontainer_file" <<EOF
{
  "name": "Multi-worktree: ${task_name}",
  "build": {
    "dockerfile": "\${localEnv:HOME}/.config/devcontainer/Dockerfile"
  },
  "workspaceFolder": "/workspaces/${worktree_name}",
  "mounts": $(echo -e "$mounts"),
  "remoteEnv": {
    "GH_TOKEN": "\${localEnv:GH_TOKEN}",
    "TERM": "xterm-256color",
    "CCMANAGER_WORKTREE_PATH": "/workspaces/${worktree_name}",
    "CCMANAGER_WORKTREE_BRANCH": "${task_name}"
  },
  "postCreateCommand": "",
  "postStartCommand": "mise trust"
}
EOF

    log_success "devcontainer.json を生成しました: $devcontainer_file"
}

# 全グループ名を取得する
get_all_groups() {
    local groups=()
    local in_groups_section=false

    while IFS= read -r line; do
        # コメントと空行をスキップ
        [[ "$line" =~ ^[[:space:]]*# ]] && continue

        # [groups.xxx] の形式を検出
        if [[ "$line" =~ ^\[groups\.([^]]+)\] ]]; then
            local group_name="${BASH_REMATCH[1]}"
            groups+=("$group_name")
        fi
    done < "$CONFIG_FILE"

    printf '%s\n' "${groups[@]}"
}

# list サブコマンド
cmd_list() {
    # 全グループを取得
    local all_groups=()
    while IFS= read -r group; do
        all_groups+=("$group")
    done < <(get_all_groups)

    # グループが1つも見つからない場合
    if [[ ${#all_groups[@]} -eq 0 ]]; then
        log_error "設定ファイルにグループが見つかりません" >&2
        return 1
    fi

    # 各グループのworktreeを表示
    for group in "${all_groups[@]}"; do
        local base_dir=$(expand_path "$(get_config_value "$group" "base_dir")")
        local prefix=$(get_config_value "$group" "worktree_prefix")

        if [[ -z "$base_dir" ]] || [[ -z "$prefix" ]]; then
            continue
        fi

        # base_dirを絶対パスに解決（共通関数を使用）
        base_dir=$(resolve_base_dir "$base_dir" "$group")

        # worktree ディレクトリを検索（TSV形式で出力）
        if [[ ! -d "$base_dir" ]]; then
            continue
        fi

        for dir in "$base_dir"/${prefix}-*; do
            # globパターンにマッチするものがない場合、パターン自体が返される
            # その場合はスキップ
            if [[ ! -e "$dir" ]]; then
                continue
            fi

            if [[ -d "$dir" ]]; then
                local task_dir_name=$(basename "$dir" | sed "s/^${prefix}-//")
                local task_name=$(echo "$task_dir_name" | sed 's/-/\//g')

                # リポジトリ数をカウント
                local repo_count=$(find "$dir" -mindepth 1 -maxdepth 1 -type d ! -name ".*" | wc -l | tr -d ' ')

                # devcontainer の有無を確認
                local has_devcontainer=""
                if [[ -f "$dir/.devcontainer/devcontainer.json" ]]; then
                    has_devcontainer="devcontainer"
                fi

                # TSV形式で出力: <task-name>\t<group>\t<path>\t<repo-count> repos\t[devcontainer]
                echo -e "${task_name}\t${group}\t${dir}\t${repo_count} repos\t${has_devcontainer}"
            fi
        done
    done
}

# status サブコマンド
cmd_status() {
    local task_name="$1"
    local group=$(get_default_group)

    local worktree_base_dir=$(get_worktree_base_dir "$task_name" "$group")

    if [[ ! -d "$worktree_base_dir" ]]; then
        log_error "タスク '$task_name' の worktree が見つかりません: $worktree_base_dir"
        return 1
    fi

    log_info "タスク '$task_name' のステータス"
    log_info "ディレクトリ: $worktree_base_dir"
    echo ""

    # 各リポジトリのステータスを表示
    for repo_dir in "$worktree_base_dir"/*; do
        if [[ -d "$repo_dir" ]] && [[ ! "$(basename "$repo_dir")" =~ ^\. ]]; then
            local repo_name=$(basename "$repo_dir")

            echo -e "${BLUE}=== $repo_name ===${NC}"

            (
                cd "$repo_dir"

                # ブランチ情報
                local branch=$(git branch --show-current 2>/dev/null || echo "unknown")
                echo "ブランチ: $branch"

                # 変更状況
                if [[ -n "$(git status --porcelain 2>/dev/null)" ]]; then
                    echo -e "${YELLOW}変更あり${NC}"
                    git status --short
                else
                    echo -e "${GREEN}変更なし${NC}"
                fi

                # 最新のコミット
                echo ""
                echo "最新のコミット:"
                git log --oneline -3 2>/dev/null || echo "コミット履歴なし"
            )

            echo ""
        fi
    done
}

# cd サブコマンド
cmd_cd() {
    local task_name="$1"
    local group=$(get_default_group)

    local worktree_base_dir=$(get_worktree_base_dir "$task_name" "$group")

    if [[ ! -d "$worktree_base_dir" ]]; then
        log_error "タスク '$task_name' の worktree が見つかりません: $worktree_base_dir"
        return 1
    fi

    log_info "worktree ディレクトリに移動します: $worktree_base_dir"
    log_success "新しいシェルを起動します。exit で戻ります。"

    # worktree ディレクトリに移動
    cd "$worktree_base_dir" || return 1

    # シェルを起動（SHELL 環境変数を使用、デフォルトは bash）
    local shell="${SHELL:-/bin/bash}"
    exec "$shell"
}

# exec サブコマンド
cmd_exec() {
    local task_name="$1"
    shift

    if [[ $# -eq 0 ]]; then
        log_error "実行するコマンドを指定してください"
        return 1
    fi

    local command="$@"
    local group=$(get_default_group)

    local worktree_base_dir=$(get_worktree_base_dir "$task_name" "$group")

    if [[ ! -d "$worktree_base_dir" ]]; then
        log_error "タスク '$task_name' の worktree が見つかりません: $worktree_base_dir"
        return 1
    fi

    log_info "タスク '$task_name' で devcontainer を起動します"

    # 設定の読み込み
    local up_opts=$(get_devcontainer_up_opts "$group")
    local exec_opts=$(get_devcontainer_exec_opts "$group")
    local skip_up=$(get_devcontainer_skip_up_if_running)

    # worktree ディレクトリに移動
    cd "$worktree_base_dir" || return 1

    # devcontainer が起動しているかチェック
    local is_running=false
    if [[ "$skip_up" == "true" ]]; then
        # コンテナが起動しているかチェック（簡易版）
        local container_name=$(basename "$worktree_base_dir")
        if docker ps --format '{{.Names}}' 2>/dev/null | grep -q "$container_name"; then
            is_running=true
            log_info "devcontainer は既に起動しています"
        fi
    fi

    # devcontainer up の実行
    if [[ "$is_running" == "false" ]]; then
        log_info "devcontainer を起動中..."

        # オプションを配列として解析して安全に実行
        local -a up_args
        read -ra up_args <<< "$up_opts"
        devcontainer up "${up_args[@]}"

        if [[ $? -ne 0 ]]; then
            log_error "devcontainer の起動に失敗しました"
            return 1
        fi
    fi

    # devcontainer exec の実行
    log_info "コマンドを実行中: $command"

    # オプションを配列として解析して安全に実行
    local -a exec_args
    read -ra exec_args <<< "$exec_opts"
    devcontainer exec "${exec_args[@]}" "$@"

    local exit_code=$?

    if [[ $exit_code -ne 0 ]]; then
        log_error "コマンドの実行に失敗しました (終了コード: $exit_code)"
        return $exit_code
    fi

    log_success "コマンドが正常に完了しました"
}

# sync サブコマンド
cmd_sync() {
    local task_name="$1"
    shift
    local selected_repos=("$@")  # 選択されたリポジトリ名（引数で渡される）
    local group=$(get_default_group)

    local worktree_base_dir=$(get_worktree_base_dir "$task_name" "$group")

    if [[ ! -d "$worktree_base_dir" ]]; then
        log_error "タスク '$task_name' の worktree が見つかりません: $worktree_base_dir"
        return 1
    fi

    log_info "タスク '$task_name' の worktree をメインworktreeに同期します"
    log_info "ディレクトリ: $worktree_base_dir"
    echo ""

    # リポジトリリストの取得
    local repos=()
    while IFS= read -r repo; do
        repos+=("$repo")
    done < <(get_config_array "$group" "repos")

    # 選択されたリポジトリがある場合、それらのみをフィルタリング
    if [[ ${#selected_repos[@]} -gt 0 ]]; then
        local filtered_repos=()
        for selected in "${selected_repos[@]}"; do
            local found=false
            for repo in "${repos[@]}"; do
                local repo_name=$(basename "$repo")
                if [[ "$repo_name" == "$selected" ]]; then
                    filtered_repos+=("$repo")
                    found=true
                    break
                fi
            done
            if [[ "$found" == false ]]; then
                log_warn "リポジトリ '$selected' は設定に存在しません"
            fi
        done

        if [[ ${#filtered_repos[@]} -eq 0 ]]; then
            log_error "有効なリポジトリが選択されていません"
            return 1
        fi

        repos=("${filtered_repos[@]}")
        log_info "選択されたリポジトリ: ${#repos[@]} 個"
    fi

    # 各リポジトリで同期を実行
    local success_count=0
    local fail_count=0

    for repo in "${repos[@]}"; do
        # チルダ展開と環境変数展開
        repo="${repo/#\~/$HOME}"
        repo="${repo//\$HOME/$HOME}"
        [[ ! -d "$repo" ]] && continue

        local repo_name=$(basename "$repo")
        local worktree_path="${worktree_base_dir}/${repo_name}"

        if [[ ! -d "$worktree_path" ]]; then
            log_warn "[$repo_name] worktree が見つかりません: $worktree_path"
            continue
        fi

        log_info "[$repo_name] 同期中..."

        # サブシェルで同期処理を実行（エラーが発生しても継続）
        (
            set +e  # エラーで停止しない
            cd "$worktree_path" || exit 1

            # メインworktreeディレクトリを取得
            local main_worktree_dir
            main_worktree_dir="$(git worktree list --porcelain | head -n 1 | sed -e 's/^worktree //')"

            if [[ -z "$main_worktree_dir" ]] || [[ ! -d "$main_worktree_dir" ]]; then
                log_error "[$repo_name] メインworktreeが見つかりません"
                exit 1
            fi

            # 現在のHEADをdetachモードでメインworktreeにチェックアウト
            local current_head
            current_head="$(git rev-parse HEAD)"

            if ! git -C "$main_worktree_dir" checkout --detach "$current_head" 2>/dev/null; then
                log_error "[$repo_name] checkout --detach に失敗しました"
                exit 1
            fi

            # rsyncでファイルを同期（.gitを除外）
            if ! rsync -a --exclude '.git' "$PWD/" "$main_worktree_dir/" 2>/dev/null; then
                log_error "[$repo_name] rsync に失敗しました"
                exit 1
            fi

            log_success "[$repo_name] 同期完了: $main_worktree_dir"
            exit 0
        )

        # サブシェルの終了ステータスを確認
        if [[ $? -eq 0 ]]; then
            ((++success_count))
        else
            ((++fail_count))
        fi
    done

    echo ""
    log_info "完了: 成功 $success_count / 失敗 $fail_count"

    if [[ $fail_count -eq 0 ]]; then
        log_success "すべてのリポジトリの同期が完了しました"
    else
        log_warn "一部のリポジトリの同期に失敗しました"
        return 1
    fi
}

# open サブコマンド
cmd_open() {
    local task_name="$1"
    local group=$(get_default_group)

    local worktree_base_dir=$(get_worktree_base_dir "$task_name" "$group")

    if [[ ! -d "$worktree_base_dir" ]]; then
        log_error "タスク '$task_name' の worktree が見つかりません: $worktree_base_dir"
        return 1
    fi

    log_info "VSCode で worktree ディレクトリを開きます: $worktree_base_dir"

    # VSCodeで開く
    code "$worktree_base_dir"

    if [[ $? -eq 0 ]]; then
        log_success "VSCode を起動しました"
    else
        log_error "VSCode の起動に失敗しました"
        return 1
    fi
}

# remove サブコマンド
cmd_remove() {
    local task_name="$1"
    local group=$(get_default_group)

    local worktree_base_dir=$(get_worktree_base_dir "$task_name" "$group")

    if [[ ! -d "$worktree_base_dir" ]]; then
        log_error "タスク '$task_name' の worktree が見つかりません: $worktree_base_dir"
        return 1
    fi

    log_warn "タスク '$task_name' の worktree を削除します"
    log_info "ディレクトリ: $worktree_base_dir"
    echo ""

    # 確認
    read -p "本当に削除しますか? [y/N] " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        log_info "キャンセルしました"
        return 0
    fi

    # リポジトリリストの取得
    local repos=()
    while IFS= read -r repo; do
        repos+=("$repo")
    done < <(get_config_array "$group" "repos")

    # 各リポジトリで worktree を削除
    local success_count=0
    local fail_count=0

    for repo in "${repos[@]}"; do
        # チルダ展開と環境変数展開
        repo="${repo/#\~/$HOME}"
        repo="${repo//\$HOME/$HOME}"
        [[ ! -d "$repo" ]] && continue

        local repo_name=$(basename "$repo")
        local worktree_path="${worktree_base_dir}/${repo_name}"

        if [[ ! -d "$worktree_path" ]]; then
            continue
        fi

        log_info "[$repo_name] worktree を削除中..."

        (
            cd "$repo"
            git worktree remove "$worktree_path" --force &>/dev/null
        )

        if [[ $? -eq 0 ]]; then
            log_success "[$repo_name] worktree を削除しました"
            ((++success_count))
        else
            log_error "[$repo_name] worktree の削除に失敗しました"
            ((++fail_count))
        fi
    done

    # .devcontainer ディレクトリなど、git worktree remove で削除されない残存ファイルを削除
    if [[ $fail_count -eq 0 ]]; then
        if [[ -d "$worktree_base_dir" ]]; then
            # 空でないディレクトリが残っている場合のみ削除
            if [[ -n "$(ls -A "$worktree_base_dir" 2>/dev/null)" ]]; then
                rm -rf "$worktree_base_dir"
                log_success "残存ディレクトリを削除しました: $worktree_base_dir"
            fi
        fi
    else
        log_warn "一部の worktree 削除に失敗したため、ディレクトリは残します: $worktree_base_dir"
        log_info "手動で確認・修正後、再度削除を実行してください"
    fi

    log_info "完了: 成功 $success_count / 失敗 $fail_count"
}

# メイン処理
main() {
    if [[ $# -eq 0 ]]; then
        show_usage
        return 1
    fi

    local subcommand="$1"
    shift

    case "$subcommand" in
        create)
            check_config || return 1

            if [[ $# -eq 0 ]]; then
                log_error "タスク名を指定してください"
                show_usage
                return 1
            fi

            local task_name="$1"
            local group=$(get_default_group)

            shift
            while [[ $# -gt 0 ]]; do
                case "$1" in
                    --group=*)
                        group="${1#*=}"
                        ;;
                    *)
                        log_error "不明なオプション: $1"
                        return 1
                        ;;
                esac
                shift
            done

            cmd_create "$task_name" "$group"
            ;;

        list)
            check_config || return 1
            cmd_list
            ;;

        status)
            check_config || return 1

            if [[ $# -eq 0 ]]; then
                log_error "タスク名を指定してください"
                show_usage
                return 1
            fi

            cmd_status "$1"
            ;;

        sync)
            check_config || return 1

            if [[ $# -eq 0 ]]; then
                log_error "タスク名を指定してください"
                show_usage
                return 1
            fi

            local task_name="$1"
            shift

            cmd_sync "$task_name" "$@"
            ;;

        cd)
            check_config || return 1

            if [[ $# -eq 0 ]]; then
                log_error "タスク名を指定してください"
                show_usage
                return 1
            fi

            cmd_cd "$1"
            ;;

        exec)
            check_config || return 1

            if [[ $# -eq 0 ]]; then
                log_error "タスク名を指定してください"
                show_usage
                return 1
            fi

            local task_name="$1"
            shift

            cmd_exec "$task_name" "$@"
            ;;

        open)
            check_config || return 1

            if [[ $# -eq 0 ]]; then
                log_error "タスク名を指定してください"
                show_usage
                return 1
            fi

            cmd_open "$1"
            ;;

        remove)
            check_config || return 1

            if [[ $# -eq 0 ]]; then
                log_error "タスク名を指定してください"
                show_usage
                return 1
            fi

            cmd_remove "$1"
            ;;

        help|--help|-h)
            show_usage
            ;;

        *)
            log_error "不明なサブコマンド: $subcommand"
            show_usage
            return 1
            ;;
    esac
}

main "$@"
